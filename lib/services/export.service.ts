"use server";

import type { SimplificationMode, SimplificationStatistics } from "@/lib/types";

export interface ExportData {
  originalText: string;
  simplifiedText: string;
  mode: SimplificationMode;
  statistics?: SimplificationStatistics;
  createdAt?: Date;
  title?: string;
}

export interface ExportResult {
  success: boolean;
  data?: string;
  filename?: string;
  mimeType?: string;
  error?: string;
}

type ExportFormat = "txt" | "md" | "json" | "html" | "pdf";

/**
 * Export simplification data to various formats
 */
export async function exportSimplification(
  data: ExportData,
  format: ExportFormat
): Promise<ExportResult> {
  try {
    const title = data.title ?? "Simplified Text";
    const createdDate = data.createdAt
      ? new Date(data.createdAt).toLocaleDateString()
      : new Date().toLocaleDateString();

    switch (format) {
      case "txt":
        return exportToTxt(data, title, createdDate);
      case "md":
        return exportToMarkdown(data, title, createdDate);
      case "json":
        return exportToJson(data);
      case "html":
        return exportToHtml(data, title, createdDate);
      case "pdf":
        return exportToPdfData(data, title, createdDate);
      default:
        return { success: false, error: "Unsupported export format" };
    }
  } catch (error) {
    console.error("Export error:", error);
    return { success: false, error: "Failed to export" };
  }
}

function exportToTxt(
  data: ExportData,
  title: string,
  date: string
): ExportResult {
  const content = `${title}
Generated on ${date}
Mode: ${formatMode(data.mode)}
${"=".repeat(50)}

ORIGINAL TEXT:
${"-".repeat(50)}
${data.originalText}

SIMPLIFIED TEXT:
${"-".repeat(50)}
${data.simplifiedText}

${data.statistics ? formatStatisticsTxt(data.statistics) : ""}
`;

  return {
    success: true,
    data: content,
    filename: `${sanitizeFilename(title)}.txt`,
    mimeType: "text/plain",
  };
}

function exportToMarkdown(
  data: ExportData,
  title: string,
  date: string
): ExportResult {
  const content = `# ${title}

**Generated:** ${date}  
**Mode:** ${formatMode(data.mode)}

---

## Original Text

${data.originalText}

---

## Simplified Text

${data.simplifiedText}

${data.statistics ? formatStatisticsMarkdown(data.statistics) : ""}
`;

  return {
    success: true,
    data: content,
    filename: `${sanitizeFilename(title)}.md`,
    mimeType: "text/markdown",
  };
}

function exportToJson(data: ExportData): ExportResult {
  const content = JSON.stringify(
    {
      title: data.title ?? "Simplified Text",
      mode: data.mode,
      originalText: data.originalText,
      simplifiedText: data.simplifiedText,
      statistics: data.statistics,
      createdAt: data.createdAt?.toISOString() ?? new Date().toISOString(),
      exportedAt: new Date().toISOString(),
    },
    null,
    2
  );

  return {
    success: true,
    data: content,
    filename: `${sanitizeFilename(data.title ?? "simplified-text")}.json`,
    mimeType: "application/json",
  };
}

function exportToHtml(
  data: ExportData,
  title: string,
  date: string
): ExportResult {
  const content = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${escapeHtml(title)}</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 2rem;
      line-height: 1.6;
      color: #333;
    }
    h1 { color: #1a1a1a; border-bottom: 2px solid #e5e5e5; padding-bottom: 0.5rem; }
    h2 { color: #4a4a4a; margin-top: 2rem; }
    .meta { color: #666; font-size: 0.9rem; margin-bottom: 2rem; }
    .content { background: #f9f9f9; padding: 1.5rem; border-radius: 8px; margin: 1rem 0; }
    .stats { background: #e8f4f8; padding: 1rem; border-radius: 8px; margin-top: 2rem; }
    .stats h3 { margin-top: 0; }
    .stat-item { display: flex; justify-content: space-between; padding: 0.25rem 0; }
  </style>
</head>
<body>
  <h1>${escapeHtml(title)}</h1>
  <div class="meta">
    <strong>Generated:</strong> ${date}<br>
    <strong>Mode:</strong> ${formatMode(data.mode)}
  </div>
  
  <h2>Original Text</h2>
  <div class="content">${escapeHtml(data.originalText).replace(
    /\n/g,
    "<br>"
  )}</div>
  
  <h2>Simplified Text</h2>
  <div class="content">${escapeHtml(data.simplifiedText).replace(
    /\n/g,
    "<br>"
  )}</div>
  
  ${data.statistics ? formatStatisticsHtml(data.statistics) : ""}
  
  <footer style="margin-top: 3rem; padding-top: 1rem; border-top: 1px solid #e5e5e5; font-size: 0.8rem; color: #888;">
    Generated by ClarityWeb
  </footer>
</body>
</html>`;

  return {
    success: true,
    data: content,
    filename: `${sanitizeFilename(title)}.html`,
    mimeType: "text/html",
  };
}

function exportToPdfData(
  data: ExportData,
  title: string,
  date: string
): ExportResult {
  // For PDF, we return HTML with proper print styles for pagination
  const MAX_CHARS_PER_PAGE = 2500; // Roughly one page of text

  // Split long texts into manageable chunks
  const splitTextIntoPages = (text: string): string[] => {
    const words = text.split(/\s+/);
    const pages: string[] = [];
    let currentPage = "";
    let currentLength = 0;

    for (const word of words) {
      if (currentLength + word.length > MAX_CHARS_PER_PAGE && currentPage) {
        pages.push(currentPage.trim());
        currentPage = word + " ";
        currentLength = word.length + 1;
      } else {
        currentPage += word + " ";
        currentLength += word.length + 1;
      }
    }

    if (currentPage.trim()) {
      pages.push(currentPage.trim());
    }

    return pages.length > 0 ? pages : [text];
  };

  const originalPages = splitTextIntoPages(data.originalText);
  const simplifiedPages = splitTextIntoPages(data.simplifiedText);

  const originalPagesHtml = originalPages
    .map(
      (page, idx) =>
        `<div class="page-content">
      ${
        originalPages.length > 1
          ? `<div class="page-number">Page ${idx + 1}/${
              originalPages.length
            }</div>`
          : ""
      }
      ${escapeHtml(page).replace(/\n/g, "<br>")}
    </div>`
    )
    .join('<div class="page-break"></div>');

  const simplifiedPagesHtml = simplifiedPages
    .map(
      (page, idx) =>
        `<div class="page-content">
      ${
        simplifiedPages.length > 1
          ? `<div class="page-number">Page ${idx + 1}/${
              simplifiedPages.length
            }</div>`
          : ""
      }
      ${escapeHtml(page).replace(/\n/g, "<br>")}
    </div>`
    )
    .join('<div class="page-break"></div>');

  const htmlContent = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${escapeHtml(title)}</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 2rem;
      line-height: 1.6;
      color: #333;
    }
    h1 { 
      color: #1a1a1a; 
      border-bottom: 2px solid #e5e5e5; 
      padding-bottom: 0.5rem;
      page-break-after: avoid;
    }
    h2 { 
      color: #4a4a4a; 
      margin-top: 2rem;
      page-break-after: avoid;
      page-break-before: auto;
    }
    .meta { 
      color: #666; 
      font-size: 0.9rem; 
      margin-bottom: 2rem;
      page-break-after: avoid;
    }
    .content { 
      background: #f9f9f9; 
      padding: 1.5rem; 
      border-radius: 8px; 
      margin: 1rem 0;
      page-break-inside: avoid;
    }
    .page-content {
      margin-bottom: 1rem;
      orphans: 3;
      widows: 3;
    }
    .page-number {
      font-size: 0.8rem;
      color: #888;
      margin-bottom: 0.5rem;
      text-align: right;
    }
    .page-break {
      page-break-before: always;
    }
    .stats { 
      background: #e8f4f8; 
      padding: 1rem; 
      border-radius: 8px; 
      margin-top: 2rem;
      page-break-inside: avoid;
    }
    .stats h3 { 
      margin-top: 0;
      page-break-after: avoid;
    }
    .stat-item { 
      display: flex; 
      justify-content: space-between; 
      padding: 0.25rem 0;
    }
    footer {
      margin-top: 3rem;
      padding-top: 1rem;
      border-top: 1px solid #e5e5e5;
      font-size: 0.8rem;
      color: #888;
      page-break-inside: avoid;
    }
    
    @media print {
      body { 
        margin: 0; 
        padding: 1.5cm;
      }
      @page { 
        margin: 2cm;
        size: A4;
      }
      .page-break {
        page-break-before: always;
      }
      h1, h2 {
        page-break-after: avoid;
      }
      .content {
        background: transparent;
        border: 1px solid #ddd;
      }
    }
  </style>
</head>
<body>
  <h1>${escapeHtml(title)}</h1>
  <div class="meta">
    <strong>Generated:</strong> ${date}<br>
    <strong>Mode:</strong> ${formatMode(data.mode)}
  </div>
  
  <h2>Original Text</h2>
  <div class="content">${originalPagesHtml}</div>
  
  <div class="page-break"></div>
  
  <h2>Simplified Text</h2>
  <div class="content">${simplifiedPagesHtml}</div>
  
  ${data.statistics ? formatStatisticsHtml(data.statistics) : ""}
  
  <footer>
    Generated by ClarityWeb
  </footer>
</body>
</html>`;

  return {
    success: true,
    data: htmlContent,
    filename: `${sanitizeFilename(title)}.pdf`,
    mimeType: "text/html", // Client will print to PDF
  };
}

// Helper functions
function formatMode(mode: SimplificationMode): string {
  const modeNames: Record<SimplificationMode, string> = {
    simple: "Simple Mode",
    accessible: "Accessible Mode",
    summary: "Summary Mode",
  };
  return modeNames[mode] ?? mode;
}

function sanitizeFilename(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-|-$/g, "")
    .slice(0, 50);
}

function escapeHtml(text: string): string {
  return text
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

function formatStatisticsTxt(stats: SimplificationStatistics): string {
  return `STATISTICS:
${"-".repeat(50)}
Original: ${
    stats.wordsCountBefore
  } words, Flesch Score: ${stats.fleschBefore.toFixed(1)}
Simplified: ${
    stats.wordsCountAfter
  } words, Flesch Score: ${stats.fleschAfter.toFixed(1)}
Reading Time: ${stats.readingTimeBefore}s → ${stats.readingTimeAfter}s
${stats.improvement ? `Improvement: ${stats.improvement.toFixed(1)}%` : ""}
`;
}

function formatStatisticsMarkdown(stats: SimplificationStatistics): string {
  return `---

## Statistics

| Metric | Original | Simplified |
|--------|----------|------------|
| Words | ${stats.wordsCountBefore} | ${stats.wordsCountAfter} |
| Flesch Score | ${stats.fleschBefore.toFixed(1)} | ${stats.fleschAfter.toFixed(
    1
  )} |
| Reading Time | ${stats.readingTimeBefore}s | ${stats.readingTimeAfter}s |

${stats.improvement ? `**Improvement:** ${stats.improvement.toFixed(1)}%` : ""}
`;
}

function formatStatisticsHtml(stats: SimplificationStatistics): string {
  return `
  <div class="stats">
    <h3>Statistics</h3>
    <div class="stat-item"><span>Original Words:</span> <strong>${
      stats.wordsCountBefore
    }</strong></div>
    <div class="stat-item"><span>Simplified Words:</span> <strong>${
      stats.wordsCountAfter
    }</strong></div>
    <div class="stat-item"><span>Original Flesch Score:</span> <strong>${stats.fleschBefore.toFixed(
      1
    )}</strong></div>
    <div class="stat-item"><span>Simplified Flesch Score:</span> <strong>${stats.fleschAfter.toFixed(
      1
    )}</strong></div>
    <div class="stat-item"><span>Reading Time:</span> <strong>${
      stats.readingTimeBefore
    }s → ${stats.readingTimeAfter}s</strong></div>
    ${
      stats.improvement
        ? `<div class="stat-item"><span>Improvement:</span> <strong>${stats.improvement.toFixed(
            1
          )}%</strong></div>`
        : ""
    }
  </div>`;
}
